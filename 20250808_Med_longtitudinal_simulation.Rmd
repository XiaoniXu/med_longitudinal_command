---
title: "20250808_Data_Sample"
author: "Xiaoni Xu"
date: "2025-08-09"
output: html_document
---
Loading libraries
```{r}
library(SimDesign)
library(timereg)
library(tidyr)
library(dplyr)
library(mice)
library(splitstackshape)
library(foreach)
library(survival)
library(mvtnorm)

set.seed(2025)
```

```{r}
med_longitudinal=function(L=NULL, M, m, Y, treat='logcocr', control.value=a, treat.value=a_star, data, time_points, peryr=100000){
  
  N=dim(data)[1]
  NL=length(L)
  NM=length(M)
  
  # bootstrap loop, 10000 iterations
  boot <- foreach(i=1:10000, .combine='rbind') %dopar% {
    ind <- sample(1:N, replace=TRUE)
   
    # parameters for mediator models
    MModel = list()
    for (i in 1:NM){
      MModel[[i]] <- rmvnorm(1, mean = coef(M[[i]]), sigma = vcov(M[[i]]))
    }
    # parameters for outcome model
    YModel = rmvnorm(1, mean = Y$gamma, sigma = Y$robvar.gamma)
    
    # initialize empty matrices to store simulated values
    # store binary predictions of whether each subject drops out at each time point under the counterfactual
    # a: control treatment
    # astar: treated
    # predictL_a: dropout under control
    # predictL_astar: dropout under treatment
    # predictL_astar_a: dropout under treatment with a mediator
    # predictM_a: mediator under control
    # predictM_astar: mediator under treatment
    # predictM_a_astar: mediator under control with treatment a*
    PredictL_a <- PredictL_astar <- PredictL_astar_a <- matrix(NA,nrow=N,ncol=NL)
    PredictM_a <- PredictM_astar <- PredictM_a_astar <- matrix(NA,nrow=N,ncol=NM)
    
    # simulate first time-point mediator value under two different counterfactual treatment scenarios for each individual in the bootstrap sample
    # Predict M1
    # create counterfactual datasets for mediator 1
    pred.data.astar.m1 <- pred.data.a.m1 <- model.frame(M[[1]])[ind,]
    # set treatment values
    pred.data.astar.m1[, treat] <- treat.value
    pred.data.a.m1[, treat] <- control.value
    # generate model matrices
    m1mat.astar <- model.matrix(terms(M[[1]]), data = pred.data.astar.m1)
    m1mat.a <- model.matrix(terms(M[[1]]), data = pred.data.a.m1)
    # simulate predicted mediator values
    PredictM_astar[,1] <- tcrossprod(MModel[[1]], m1mat.astar)
    PredictM_a[,1] <- tcrossprod(MModel[[1]], m1mat.a)
    
    # simulate dropout/censoring at the first time point under three counterfactual scenarios
    # Predict L1
    if(NL > 0){
      pred.data.astar.l1 <- pred.data.a.l1 <- pred.data.astar.a.l1 <- model.frame(L[[1]])[ind,]
      pred.data.astar.l1[, treat] <- pred.data.astar.a.l1[, treat] <- treat.value
      pred.data.a.l1[, treat] <- control.value
      pred.data.astar.l1[, m[1]] <- PredictM_astar[,1]
      pred.data.a.l1[, m[1]] <- pred.data.astar.a.l1[, m[1]] <- PredictM_a[,1]
      # simulate dropout indicators via logistic regression
      # PredictL_a: direct effect
      # PredictL_astar: indirect effect through M
      # PredictL_astar_a: indirect effect through dropout
      PredictL_astar_a[,1] <- rbinom(N, size=1, prob=predict(L[[1]], pred.data.astar.a.l1, type='response'))
      PredictL_a[,1] <- rbinom(N, size=1, prob=predict(L[[1]], pred.data.a.l1, type='response'))
      PredictL_astar[,1] <- rbinom(N, size=1, prob=predict(L[[1]], pred.data.astar.l1, type='response'))
    }
    
    # simulate mediator and dropout beyond time 1
    # Predict Li (only if more than one time point)
    if (NM > 1){
      for (i in 2:NM){
        pred.data.a.m <- pred.data.astar.m <- pred.data.a.astar.m <- as.data.frame(matrix(nrow=N, ncol=(dim(model.frame(M[[i]]))[2]-1)))
        colnames(pred.data.a.m) <- colnames(pred.data.astar.m) <- colnames(pred.data.a.astar.m) <- attr(terms(M[[i]]),"term.labels")
        names <- colnames(pred.data.a.m)[which(colnames(pred.data.a.m) %in% attr(terms(M[[1]]),"term.labels"))]
        # set predictor values, fill baseline covariates using bootstrap sample
        pred.data.a.m[, names] <- pred.data.a.astar.m[, names] <- pred.data.astar.m[, names] <- model.frame(M[[1]])[ind,names]
        # assign treatment values for each scenario
        pred.data.a.m[, treat] <- pred.data.a.astar.m[, treat] <- control.value
        pred.data.astar.m[, treat] <- treat.value
        # assign treatment values
        pred.data.a.m[, m[i-1]] <- PredictM_a[,i-1]
        pred.data.astar.m[, m[i-1]] <- PredictM_astar[,i-1]
        pred.data.a.astar.m[, m[i-1]] <- PredictM_a_astar[,i-1]
        if(i==2){
          pred.data.a.astar.m[, m[1]] <- PredictM_a[,1]
        }
        
        # predict M_i
        # case when dropout model exists: only simulate M_i for those not dropped out at tim i-1
        if(NL > 1){
          m1mat.a.m <- model.matrix(~.,data=pred.data.a.m[which(PredictL_a[,i-1]==0),])
          m1mat.astar.m <- model.matrix(~., data = pred.data.astar.m[which(PredictL_astar[,i-1]==0),])
          m1mat.a.astar.m <- model.matrix(~., data = pred.data.a.astar.m[which(PredictL_astar_a[,i-1]==0),])
          
          PredictM_a[which(PredictL_a[,i-1]==0),i] <- tcrossprod(MModel[[i]], m1mat.a.m)
          PredictM_astar[which(PredictL_astar[,i-1]==0),i] <- tcrossprod(MModel[[i]], m1mat.astar.m)
          PredictM_a_astar[which(PredictL_astar_a[,i-1]==0),i] <- tcrossprod(MModel[[i]], m1mat.a.astar.m)
        } else{
          # case when no dropout model
          m1mat.a.m <- model.matrix(~.,data=pred.data.a.m)
          m1mat.astar.m <- model.matrix(~., data = pred.data.astar.m)
          m1mat.a.astar.m <- model.matrix(~., data = pred.data.a.astar.m)
          
          PredictM_a[,i] <- tcrossprod(MModel[[i]], m1mat.a.m)
          PredictM_astar[,i] <- tcrossprod(MModel[[i]], m1mat.astar.m)
          PredictM_a_astar[,i] <- tcrossprod(MModel[[i]], m1mat.a.astar.m)
        }
        # predict dropout at time i
        if(NL > 1 & i<=NL){
          pred.data.a.l <- pred.data.astar.l <- pred.data.astar.a.l <- as.data.frame(matrix(nrow=N, ncol=(dim(model.frame(L[[i]]))[2]-1)))
          colnames(pred.data.a.l) <- colnames(pred.data.astar.l) <- colnames(pred.data.astar.a.l) <- attr(terms(L[[i]]),"term.labels")
          names <- colnames(pred.data.a.l)[which(colnames(pred.data.a.l) %in% attr(terms(L[[1]]),"term.labels"))]
          
          pred.data.a.l[, names] <- pred.data.astar.a.l[, names] <- pred.data.astar.l[, names] <- model.frame(L[[1]])[ind,names]
          pred.data.a.l[, treat] <- control.value
          pred.data.astar.l[, treat] <- pred.data.astar.a.l[, treat] <- treat.value
          
          pred.data.a.l[, m[i]] <- PredictM_a[,i]
          pred.data.astar.l[, m[i]] <- PredictM_astar[,i]
          pred.data.astar.a.l[, m[i]] <- PredictM_a_astar[,i]
          
          PredictL_a[which(PredictL_a[,i-1]==0),i] <- rbinom(length(which(PredictL_a[,i-1]==0)), size=1, prob=predict(L[[i]], pred.data.a.l[which(PredictL_a[,i-1]==0),], type='response'))
          PredictL_astar[which(PredictL_astar[,i-1]==0),i] <- rbinom(length(which(PredictL_astar[,i-1]==0)), size=1, prob=predict(L[[i]], pred.data.astar.l[which(PredictL_astar[,i-1]==0),], type='response'))
          PredictL_astar_a[which(PredictL_astar_a[,i-1]==0),i] <- rbinom(length(which(PredictL_astar_a[,i-1]==0)), size=1, prob=predict(L[[i]], pred.data.astar.a.l[which(PredictL_astar_a[,i-1]==0),], type='response'))
        }
      }
    }
    # by the end, would have PredictM_*: matrix of predicted mediator values for all time points
    # PredictL_*: matrix of predicted dropout indicators for each time point
    
    
    # create counterfactual datasets for predicting the outcome Y (hazard), using the mediator values simulated earlier
    
    # Predict Y
    # Data augmentation method for person-time database
    # PredictY_DEIEM: a*, D1_a, M1_aD1a, D2_aD1aM1aD1a, M2_aD1aM1aD2a
      # direct effect
    # PredictY_TEDE_2: a, D1_a, M1_aD1a, D2_aD1a M1aD1a, M2_aD1aM1aD2a
      # total effect baseline
    # PredictY_IEMIED: a*, D1_a, M1_a*D1a, D2_aD1a M1a*D1a, M2_a*D1aM1a*D2a
      # indirect effect through M
    # PredictY_IEDTE_1: a*, D1_a*, M1_a*D1a*, D2_a*D1a*M1a*D1a*, M2_a*D1a*M1a*D2a*
      # total effect full
    
    pred.data.a.y <- pred.data.astar.y <- pred.data.astar.a.y <- pred.data.astar.a.astar.a.y <- data[ind,c('idno',getvarnames(Y$call)$xvar[-2],m,colnames(data)[grep('time.since.first.exam', colnames(data))])]
    pred.data.a.y[, treat] <- control.value
    pred.data.astar.y[, treat] <- pred.data.astar.a.y[, treat] <- pred.data.astar.a.astar.a.y[, treat] <- treat.value
    pred.data.a.y[, m] <- pred.data.astar.a.y[, m] <- PredictM_a
    pred.data.astar.y[, m] <- PredictM_astar
    pred.data.astar.a.astar.a.y[, m] <- PredictM_a_astar
    pred.data.astar.a.astar.a.y[, m[1]] <- PredictM_a[,1]
    

    ########################
    # prepare counterfactual datasets for predicting outcomes from the model where mediators and time-varying covariates change across time
    
    # Data augmentation method for the counterfactuals
    # reshape wide-format data into long format
    vector_time_points <- c()
    for (i in 1:length(time_points)){
      vector_time_points <- c(vector_time_points, m[i], time_points[i])
    }
    # adds an ID variable so that reshape() knows which rows belong to which subject after converting into long format
    # pred.data.a.y
    pred.data.a.y$id_boot <- seq(1:dim(pred.data.a.y)[1])
    
    # reshape each dataset into long format
    df_tv <- reshape(pred.data.a.y, direction = "long", varying = vector_time_points,
                     sep = "_", times=as.character(seq(1,length(time_points))), idvar='id_boot')
    df_tv <- df_tv[order(df_tv$id_boot),]
    # extract covariates; repeated for all four counterfactual datasets; each becomes a design matrix ready for outcome prediction
    df_pred.data.a.y <- df_tv[,match(getvarnames(Y$call)$xvar,colnames(df_tv))]
    df_pred.data.a.y <- model.matrix(~.,data=df_pred.data.a.y)[,-1]
    
    # pred.data.astar.y
    pred.data.astar.y$id_boot <- seq(1:dim(pred.data.astar.y)[1])
    df_tv <- reshape(pred.data.astar.y, direction = "long", varying = vector_time_points,
                     sep = "_", times=as.character(seq(1,length(time_points))), idvar='id_boot')
    df_tv <- df_tv[order(df_tv$idno),]
    df_pred.data.astar.y <- df_tv[,match(getvarnames(Y$call)$xvar,colnames(df_tv))]
    df_pred.data.astar.y <- model.matrix(~.,data=df_pred.data.astar.y)[,-1]
    
    # pred.data.astar.a.astar.a.y
    pred.data.astar.a.astar.a.y$id_boot <- seq(1:dim(pred.data.astar.a.astar.a.y)[1])
    df_tv <- reshape(pred.data.astar.a.astar.a.y, direction = "long", varying = vector_time_points,
                     sep = "_", times=as.character(seq(1,length(time_points))), idvar='id_boot')
    df_tv <- df_tv[order(df_tv$idno),]
    df_pred.data.astar.a.astar.a.y <- df_tv[,match(getvarnames(Y$call)$xvar,colnames(df_tv))]
    df_pred.data.astar.a.astar.a.y <- model.matrix(~.,data=df_pred.data.astar.a.astar.a.y)[,-1]
    
    # pred.data.astar.a.y
    pred.data.astar.a.y$id_boot <- seq(1:dim(pred.data.astar.a.y)[1])
    df_tv <- reshape(pred.data.astar.a.y, direction = "long", varying = vector_time_points,
                     sep = "_", times=as.character(seq(1,length(time_points))), idvar='id_boot')
    df_tv <- df_tv[order(df_tv$idno),]
    df_pred.data.astar.a.y <- df_tv[,match(getvarnames(Y$call)$xvar,colnames(df_tv))]
    df_pred.data.astar.a.y <- model.matrix(~.,data=df_pred.data.astar.a.y)[,-1]
    
    #######################
# predict counterfactual outcomes
    # each line computes a predicted hazard under a specific counterfactual scenario
    PredictY_DEIEM <- mean(tcrossprod(YModel, df_pred.data.astar.a.y))
    PredictY_TEDE_2 <- mean(tcrossprod(YModel, df_pred.data.a.y))
    PredictY_IEMIED <- mean(tcrossprod(YModel, df_pred.data.astar.a.astar.a.y))
    PredictY_IEDTE_1 <- mean(tcrossprod(YModel, df_pred.data.astar.y))
    
    # calculate mediation effects
    DE <- mean(PredictY_DEIEM - PredictY_TEDE_2)*100000
    IEM <- mean(PredictY_IEDTE_1 - PredictY_IEMIED)*100000
    IED <- mean(PredictY_IEMIED - PredictY_DEIEM)*100000
    TE <- mean(PredictY_IEDTE_1 - PredictY_TEDE_2)*100000
    # return effects for this sample
    effects <- cbind(DE, IEM, IED, TE)
    effects
  }
  
  # summary step of the function; summarizes the results into point estimates and confidence intervals
  
  # Calculate the effects
  # Direct effect
  DE <- quantile(boot[,1], 0.5)
  DE_low <- quantile(boot[,1], 0.025)
  DE_up <- quantile(boot[,1], 0.975)
  DE_result <- paste0(round(DE,2), ' (', round(DE_low, 2), ', ', round(DE_up, 2), ')')
  
  # Indirect effect through M
  IEM <- quantile(boot[,2], 0.5)
  IEM_low <- quantile(boot[,2], 0.025)
  IEM_up <- quantile(boot[,2], 0.975)
  IEM_result <- paste0(round(IEM,2), ' (', round(IEM_low, 2), ', ', round(IEM_up, 2), ')')
  
  # Indirect effect through D
  IED <- quantile(boot[,3], 0.5)
  IED_low <- quantile(boot[,3], 0.025)
  IED_up <- quantile(boot[,3], 0.975)
  IED_result <- paste0(round(IED,2), ' (', round(IED_low, 2), ', ', round(IED_up, 2), ')')
  
  # Total effect
  TE <- quantile(boot[,4], 0.5)
  TE_low <- quantile(boot[,4], 0.025)
  TE_up <- quantile(boot[,4], 0.975)
  TE_result <- paste0(round(TE,2), ' (', round(TE_low, 2), ', ', round(TE_up, 2), ')')
  
  # Relative indirect effect
  Q <- round(IEM/TE*100,2)
  
  res <- list(DE=DE_result, IEM=IEM_result, IED=IED_result, TE=TE_result, Q=Q)
  return(res)
}

```


```{r}
# 1) Simulate baseline data
N <- 2000
data <- data.frame(
  id  = 1:N,
  idno = 1:N,                     # your function grabs 'idno'
  E   = rnorm(N, 0, 1),           # continuous exposure
  C   = rbinom(N, 1, 0.5)         # binary covariate (numeric 0/1)
)

# 2) Simulate mediators (time 1 and 2)
data$M_1 <- 100 + 3*data$E + 2*data$C + rnorm(N, 0, 5)
data$M_2 <- 100 + 2*data$E + 1*data$M_1 + 1*data$C + rnorm(N, 0, 5)

# 3) Simulate dropout/censoring indicators at each time
logit <- function(x) 1/(1+exp(-x))
pD1 <- logit(-3 + 0.5*data$E + 0.02*data$M_1 + 0.5*data$C)
pD2 <- logit(-3 + 0.5*data$E + 0.02*data$M_2 + 0.5*data$C)
data$D1 <- rbinom(N, 1, pmin(pmax(pD1, 1e-6), 1-1e-6))
data$D2 <- rbinom(N, 1, pmin(pmax(pD2, 1e-6), 1-1e-6))

# 4) Simulate survival time & event
#    hazard depends on E, M_2, C; admin censor at 20
linhaz <-  -3 + 0.2*data$E + 0.01*data$M_2 + 0.2*data$C
rate   <- exp(linhaz)                         # positive rate
t_true <- rexp(N, rate = rate)                # event time
censor <- rep(20, N)                          # administrative censoring
data$time_to_event  <- pmin(t_true, censor)
data$eventHappened  <- as.integer(t_true <= censor)

# 5) Counting-process helpers your code expects later
data$tstart <- 0
data$tstop  <- data$time_to_event
data$time.since.first.exam_1 <- data$tstart
data$time.since.first.exam_2 <- data$tstop

# 6) Build df with time-dependent M for the outcome model call
df0 <- tmerge(data, data, id = id, endpt = event(time_to_event, eventHappened))
df_tv <- reshape(
  data,
  direction = "long",
  varying   = list(M = c("M_1","M_2"),
                   time.since.first.exam = c("time.since.first.exam_1","time.since.first.exam_2")),
  v.names   = c("M","time.since.first.exam"),
  times     = c("1","2"),
  timevar   = "time_index",
  idvar     = "id"
)
df_tv <- df_tv[order(df_tv$id), ]
df <- tmerge(df0, df_tv, id = id, M = tdc(time.since.first.exam, M))

# 7) Fit the models your function wants (names must match)
M1 <- lm(M_1 ~ E + C, data = data)
M2 <- lm(M_2 ~ E + M_1 + C, data = data)
L1 <- glm(D1 ~ E + M_1 + C, data = data, family = binomial())
L2 <- glm(D2 ~ E + M_2 + C, data = data, family = binomial())

# Outcome model: we only need the CALL for getvarnames(); we’ll provide
# a simple (compatible) gamma & covariance for the linear predictor draws.
Y_model <- aalen(Surv(tstart, tstop, endpt) ~ const(E) + const(M) + const(C),
                 data = df, resample.iid = 1, n.sim = 0)

# Provide a small, positive-definite covariance and mean of length 3 (E,M,C)
Y <- list(
  gamma        = c(0.02, 0.01, 0.005),              # mean coefficients for (E, M, C)
  robvar.gamma = diag(c(1e-4, 1e-4, 1e-4)),         # 3x3 covariance
  call         = Y_model$call                        # so getvarnames() works
)

# 8) Package inputs for your function
L <- list(L1 = L1, L2 = L2)
M <- list(M1 = M1, M2 = M2)
m <- c("M_1", "M_2")
time_points <- c("1", "2")
control.value <- quantile(data$E, 0.25)
treat.value   <- quantile(data$E, 0.75)

# IMPORTANT: your function uses %dopar% but you may not have a backend.
# Force sequential to avoid parallel setup.
foreach::registerDoSEQ()

# 9) Run the function (WARNING: 10,000 bootstraps will take a long time)
# For a quick smoke test, temporarily set the loop to 100 inside the function.
res <- med_longitudinal(
  L = L,
  M = M,
  m = m,
  Y = Y,
  treat = "E",
  control.value = control.value,
  treat.value = treat.value,
  data = data,
  time_points = time_points,
  peryr = 100000
)

print(res)
```



Yuchen's Data example
```{r}


load("simData.mimick.SHS.RDa")

simData <- simData[complete.cases(simData), ]
set.seed(2)  
# subset the data into 2000 rows
simData <- simData[sample(1:nrow(simData), size = 2000, replace = FALSE), ]



# start from your dataset
data <- as.data.frame(simData)

# create the names your code uses
data$M_1 <- data$M1
data$M_2 <- data$M2

# counting-process helpers your code later reshapes/uses
data$tstart <- 0
data$tstop  <- data$time_to_event
data$time.since.first.exam_1 <- data$tstart
data$time.since.first.exam_2 <- data$tstop

# ensure binarys are numeric 0/1 (glm/binomial & timereg behave better)
to01 <- function(x) as.numeric(as.character(x))
if (is.factor(data$C))  data$C  <- to01(data$C)   # your code uses const(C); make it numeric
if (is.factor(data$D1)) data$D1 <- to01(data$D1)
if (is.factor(data$D2)) data$D2 <- to01(data$D2)
if (is.factor(data$eventHappened)) data$eventHappened <- to01(data$eventHappened)
```


```{r}
M1 = lm(M_1 ~ E + C, data = data)
L1 = glm(D1 ~ E + M_1 + C, data = data, family=binomial(link='logit'))
M2 = lm(M_2 ~ E + M_1 + C, data = data)
L2 = glm(D2 ~ E + M_2 + C, data = data, family=binomial(link='logit'))
  
# Data augmentation method for counting process format for the outcome model
df <- tmerge(data, data, id=id, endpt=event(time_to_event,eventHappened))
  
# Convert the dataset with the death indicator from wide to long format
df_tv <- reshape(data, direction = "long", varying = c("M_1", "time.since.first.exam_1", "M_2", "time.since.first.exam_2"), sep = "_", times=c('1','2'), idvar='id')
df_tv <- df_tv[order(df_tv$id),]
df <- tmerge(df, df_tv, id=id, M=tdc(time.since.first.exam,M))
# In the Aalen model, factor variables need to be introduced as dummy variables for the getvarnames() fuction to work
Y = aalen(Surv(tstart, tstop, endpt) ~ const(E) + const(M) + const(C), data = df, resample.iid=1, n.sim=0)
  
# Mediation function parameters specification
treat <- 'E'
L = list(L1=L1, L2=L2)
M = list(M1=M1, M2=M2)
m <- c('M_1', 'M_2')
time_points <- c("time.since.first.exam_1", "time.since.first.exam_2")
a <- quantile(data$E, probs=0.25)
a_star <- quantile(data$E, probs=0.75)
data = data.frame(data)
control.value=a
treat.value=a_star
peryr=100000
```



```{r}
data$idno <- data$id
L <- list(L1 = L1, L2 = L2)
M <- list(M1 = M1, M2 = M2)

m <- c("M_1", "M_2")
time_points <- c("1", "2")

control.value <- quantile(data$E, 0.25)
treat.value   <- quantile(data$E, 0.75)

results <- med_longitudinal(
  L = L,
  M = M,
  m = m,
  Y = Y,
  treat = "E",                 # important: your exposure column name
  control.value = control.value,
  treat.value = treat.value,
  data = data,
  time_points = time_points,
  peryr = 100000
)

results
```

