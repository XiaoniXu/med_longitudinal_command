---
title: "20250916_Read_Med_Longitudinal"
author: "Xiaoni Xu"
date: "2025-09-16"
output: html_document
---

```{r}
library(SimDesign)
library(timereg)
library(tidyr)
library(dplyr)
library(mice)
library(splitstackshape)
library(foreach)
library(data.table)
library(survival)
library(mvtnorm)
library(parallel)
library(doParallel)
```

```{r}
load("simData.mimick.SHS.RDa")


set.seed(2)  
# subset the data into 10000 instead of 2000. 2025/8/26
simData <- simData[sample(1:nrow(simData), size = 10000, replace = FALSE), ]

simData[, M_1 := M1]
simData[, M_2 := M2]

# Counting-process helpers the outcome model needs
simData[, `:=`(tstart = 0, tstop = time_to_event,
               time.since.first.exam_1 = 0,
               time.since.first.exam_2 = time_to_event)]

# Unique ID for tmerge / reshape
simData[, id_unique := .I]

simData <- as.data.frame(simData)
```




```{r}
boot <- matrix(NA, nrow = 1000, ncol = 4)

for (i in 1:1000) {
  ind  <- sample(1L:nrow(simData), replace = TRUE)
  data <- simData[ind, ]
  data$id_unique <- seq_len(nrow(data))   # <â€” required by med_longitudinal()

  # --- mediator & dropout models ---
  M1 <- lm(M_1 ~ E + C, data = data)
  L1 <- glm(D1 ~ E + M_1 + C, data = data, family = binomial())
  M2 <- lm(M_2 ~ E + M_1 + C, data = data)
  L2 <- glm(D2 ~ E + M_2 + C, data = data, family = binomial())


  df <- survival::tmerge(
    data1 = data,
    data2 = data,
    id    = id_unique,
    endpt = event(time_to_event, eventHappened)
  )

  df_tv <- reshape(
    as.data.frame(data),
    direction = "long",
    varying   = list(
      M    = c("M_1", "M_2"),
      time = c("time.since.first.exam_1", "time.since.first.exam_2")
    ),
    v.names = c("M", "time.since.first.exam"),
    times   = c(1, 2),
    idvar   = "id_unique"
  )
  df_tv <- df_tv[order(df_tv$id_unique, df_tv$time), ]

  df <- survival::tmerge(
    data1 = df,
    data2 = df_tv,
    id    = id_unique,
    M     = tdc(time.since.first.exam, M)
  )

  Y <- timereg::aalen(
    Surv(tstart, tstop, endpt) ~ const(E) + const(M) + const(C),
    data = df,
    resample.iid = 1,
    n.sim = 0
  )

  treat <- "E"
  L     <- list(L1 = L1, L2 = L2)
  Mlist <- list(M1 = M1, M2 = M2)
  mvec  <- c("M_1", "M_2")
  tpts  <- c("time.since.first.exam_1", "time.since.first.exam_2")

  a      <- as.numeric(quantile(data$E, 0.25, na.rm = TRUE))
  a_star <- as.numeric(quantile(data$E, 0.75, na.rm = TRUE))

  out <- med_longitudinal(
    L = L, M = Mlist, m = mvec, Y = Y, treat = treat,
    control.value = a, treat.value = a_star,
    data = data, time_points = tpts, peryr = 100000
  )

  boot[i, ] <- as.numeric(out)
}
```

see the results
```{r}
## 1) Make sure columns are named
if (is.null(colnames(boot)) || any(colnames(boot) == "")) {
  colnames(boot) <- c("DE","IEM","IED","TE")
}

## 2) Basic sanity checks
colSums(!is.finite(boot))     # count NA/Inf per column
summary(as.data.frame(boot))  # quick five-number summaries
head(boot, 5)

## 3) Percentile estimates and 95% CIs (2.5%, 50%, 97.5%)
qfun <- function(x) {
  qs <- quantile(x, c(.025,.5,.975), na.rm = TRUE)
  c(LCL = qs[1], Median = qs[2], UCL = qs[3], SD = sd(x, na.rm=TRUE))
}

summ <- t(apply(boot, 2, qfun))
round(summ, 3)

```



```{r}
# Mediation main function
med_longitudinal=function(L=NULL, M, m, Y, treat='logcocr', control.value=a, treat.value=a_star, data, time_points, peryr=100000){
  
  data <- as.data.frame(data, stringsAsFactors = FALSE)
  N  <- nrow(data)
  NL=length(L)
  NM=length(M)
  
  MModel = list()
  for (i in 1:NM){
    MModel[[i]] <- rmvnorm(1, mean = coef(M[[i]]), sigma = vcov(M[[i]]))
  }
  
  YModel = rmvnorm(1, mean = Y$gamma, sigma = Y$robvar.gamma)
  
  PredictL_a <- PredictL_astar <- PredictL_astar_a <- matrix(NA,nrow=N,ncol=NL)
  PredictM_a <- PredictM_astar <- PredictM_a_astar <- matrix(NA,nrow=N,ncol=NM)
  
  # Predict M1
  pred.data.astar.m1 <- pred.data.a.m1 <- model.frame(M[[1]])
  pred.data.astar.m1[, treat] <- treat.value
  pred.data.a.m1[, treat] <- control.value
  
  m1mat.astar <- model.matrix(terms(M[[1]]), data = pred.data.astar.m1)
  m1mat.a <- model.matrix(terms(M[[1]]), data = pred.data.a.m1)
  
  PredictM_astar[,1] <- tcrossprod(MModel[[1]], m1mat.astar)
  PredictM_a[,1] <- tcrossprod(MModel[[1]], m1mat.a)
  
  # Predict L1
  if(NL > 0){
    pred.data.astar.l1 <- pred.data.a.l1 <- pred.data.astar.a.l1 <- model.frame(L[[1]])
    pred.data.astar.l1[, treat] <- pred.data.astar.a.l1[, treat] <- treat.value
    pred.data.a.l1[, treat] <- control.value
    pred.data.astar.l1[, m[1]] <- PredictM_astar[,1]
    pred.data.a.l1[, m[1]] <- pred.data.astar.a.l1[, m[1]] <- PredictM_a[,1]
    
    PredictL_astar_a[,1] <- rbinom(N, size=1, prob=predict(L[[1]], pred.data.astar.a.l1, type='response'))
    PredictL_a[,1] <- rbinom(N, size=1, prob=predict(L[[1]], pred.data.a.l1, type='response'))
    PredictL_astar[,1] <- rbinom(N, size=1, prob=predict(L[[1]], pred.data.astar.l1, type='response'))
  }
  
  # Predict Li (only if more than one time point)
  if (NM > 1){
    for (i in 2:NM){
      pred.data.a.m <- pred.data.astar.m <- pred.data.a.astar.m <- as.data.frame(matrix(nrow=N, ncol=(dim(model.frame(M[[i]]))[2]-1)))
      colnames(pred.data.a.m) <- colnames(pred.data.astar.m) <- colnames(pred.data.a.astar.m) <- attr(terms(M[[i]]),"term.labels")
      names <- colnames(pred.data.a.m)[which(colnames(pred.data.a.m) %in% attr(terms(M[[1]]),"term.labels"))]
      
      pred.data.a.m[, names] <- pred.data.a.astar.m[, names] <- pred.data.astar.m[, names] <- model.frame(M[[1]])[,names]
      pred.data.a.m[, treat] <- pred.data.a.astar.m[, treat] <- control.value
      pred.data.astar.m[, treat] <- treat.value
      
      pred.data.a.m[, m[i-1]] <- PredictM_a[,i-1]
      pred.data.astar.m[, m[i-1]] <- PredictM_astar[,i-1]
      pred.data.a.astar.m[, m[i-1]] <- PredictM_a_astar[,i-1]
      if(i==2){
        pred.data.a.astar.m[, m[1]] <- PredictM_a[,1]
      }
      
      if(NL > 1){
        m1mat.a.m <- model.matrix(~.,data=pred.data.a.m[which(PredictL_a[,i-1]==0),])
        m1mat.astar.m <- model.matrix(~., data = pred.data.astar.m[which(PredictL_astar[,i-1]==0),])
        m1mat.a.astar.m <- model.matrix(~., data = pred.data.a.astar.m[which(PredictL_astar_a[,i-1]==0),])
        
        PredictM_a[which(PredictL_a[,i-1]==0),i] <- tcrossprod(MModel[[i]], m1mat.a.m)
        PredictM_astar[which(PredictL_astar[,i-1]==0),i] <- tcrossprod(MModel[[i]], m1mat.astar.m)
        PredictM_a_astar[which(PredictL_astar_a[,i-1]==0),i] <- tcrossprod(MModel[[i]], m1mat.a.astar.m)
      } else{
        m1mat.a.m <- model.matrix(~.,data=pred.data.a.m)
        m1mat.astar.m <- model.matrix(~., data = pred.data.astar.m)
        m1mat.a.astar.m <- model.matrix(~., data = pred.data.a.astar.m)
        
        PredictM_a[,i] <- tcrossprod(MModel[[i]], m1mat.a.m)
        PredictM_astar[,i] <- tcrossprod(MModel[[i]], m1mat.astar.m)
        PredictM_a_astar[,i] <- tcrossprod(MModel[[i]], m1mat.a.astar.m)
      }
      
      if(NL > 1 & i<=NL){
        pred.data.a.l <- pred.data.astar.l <- pred.data.astar.a.l <- as.data.frame(matrix(nrow=N, ncol=(dim(model.frame(L[[i]]))[2]-1)))
        colnames(pred.data.a.l) <- colnames(pred.data.astar.l) <- colnames(pred.data.astar.a.l) <- attr(terms(L[[i]]),"term.labels")
        names <- colnames(pred.data.a.l)[which(colnames(pred.data.a.l) %in% attr(terms(L[[1]]),"term.labels"))]
        
        pred.data.a.l[, names] <- pred.data.astar.a.l[, names] <- pred.data.astar.l[, names] <- model.frame(L[[1]])[,names]
        pred.data.a.l[, treat] <- control.value
        pred.data.astar.l[, treat] <- pred.data.astar.a.l[, treat] <- treat.value
        
        pred.data.a.l[, m[i]] <- PredictM_a[,i]
        pred.data.astar.l[, m[i]] <- PredictM_astar[,i]
        pred.data.astar.a.l[, m[i]] <- PredictM_a_astar[,i]
        
        PredictL_a[which(PredictL_a[,i-1]==0),i] <- rbinom(length(which(PredictL_a[,i-1]==0)), size=1, prob=predict(L[[i]], pred.data.a.l[which(PredictL_a[,i-1]==0),], type='response'))
        PredictL_astar[which(PredictL_astar[,i-1]==0),i] <- rbinom(length(which(PredictL_astar[,i-1]==0)), size=1, prob=predict(L[[i]], pred.data.astar.l[which(PredictL_astar[,i-1]==0),], type='response'))
        PredictL_astar_a[which(PredictL_astar_a[,i-1]==0),i] <- rbinom(length(which(PredictL_astar_a[,i-1]==0)), size=1, prob=predict(L[[i]], pred.data.astar.a.l[which(PredictL_astar_a[,i-1]==0),], type='response'))
      }
    }
  }
  
  
    # ---- Predict Y (robust to 1-column subsets) ----
  # helper to keep data.frame shape & set treatment safely
  .keep_df <- function(x) as.data.frame(x, stringsAsFactors = FALSE)
  .set_treat <- function(df, treat, val) { df[[treat]] <- val; df }
  
  # columns needed for Y prediction
  y_xvars <- getvarnames(Y$call)$xvar          # from timereg::aalen call
  # (Your code uses y_xvars[-2]; keep that behavior if required)
  y_xvars <- y_xvars[-2]
  
  time_cols <- grep('time.since.first.exam', colnames(data), value = TRUE)
  cols_y <- c('id_unique', y_xvars, m, time_cols)
  
  pred.data.a.y               <- .keep_df(data[, cols_y, drop = FALSE])
  pred.data.astar.y           <- .keep_df(data[, cols_y, drop = FALSE])
  pred.data.astar.a.y         <- .keep_df(data[, cols_y, drop = FALSE])
  pred.data.astar.a.astar.a.y <- .keep_df(data[, cols_y, drop = FALSE])
  
  pred.data.a.y               <- .set_treat(pred.data.a.y,               treat, control.value)
  pred.data.astar.y           <- .set_treat(pred.data.astar.y,           treat, treat.value)
  pred.data.astar.a.y         <- .set_treat(pred.data.astar.a.y,         treat, treat.value)
  pred.data.astar.a.astar.a.y <- .set_treat(pred.data.astar.a.astar.a.y, treat, treat.value)
  
  # plug in mediator predictions
  pred.data.a.y[, m]               <- PredictM_a
  pred.data.astar.y[, m]           <- PredictM_astar
  pred.data.astar.a.astar.a.y[, m] <- PredictM_a_astar
  pred.data.astar.a.y[, m]         <- PredictM_a      # a* for treat, a for mediator
  pred.data.astar.a.astar.a.y[, m[1]] <- PredictM_a[,1]  # keep your special-case line
  
  # ----- build long data & model matrices -----
  vector_time_points <- as.vector(rbind(m, time_points))  # m1, t1, m2, t2, ...
  
  # pred.data.a.y
  df_tv <- reshape(pred.data.a.y, direction = "long", varying = vector_time_points,
                   sep = "_", times = as.character(seq_along(time_points)),
                   idvar = 'id_unique')
  df_tv <- df_tv[order(df_tv$id_unique), ]
  df_pred.data.a.y <- df_tv[, match(getvarnames(Y$call)$xvar, colnames(df_tv)), drop = FALSE]
  df_pred.data.a.y <- model.matrix(~ ., data = df_pred.data.a.y)[, -1, drop = FALSE]
  
  # pred.data.astar.y
  df_tv <- reshape(pred.data.astar.y, direction = "long", varying = vector_time_points,
                   sep = "_", times = as.character(seq_along(time_points)),
                   idvar = 'id_unique')
  df_tv <- df_tv[order(df_tv$id_unique), ]
  df_pred.data.astar.y <- df_tv[, match(getvarnames(Y$call)$xvar, colnames(df_tv)), drop = FALSE]
  df_pred.data.astar.y <- model.matrix(~ ., data = df_pred.data.astar.y)[, -1, drop = FALSE]
  
  # pred.data.astar.a.astar.a.y
  df_tv <- reshape(pred.data.astar.a.astar.a.y, direction = "long", varying = vector_time_points,
                   sep = "_", times = as.character(seq_along(time_points)),
                   idvar = 'id_unique')
  df_tv <- df_tv[order(df_tv$id_unique), ]
  df_pred.data.astar.a.astar.a.y <- df_tv[, match(getvarnames(Y$call)$xvar, colnames(df_tv)), drop = FALSE]
  df_pred.data.astar.a.astar.a.y <- model.matrix(~ ., data = df_pred.data.astar.a.astar.a.y)[, -1, drop = FALSE]
  
  # pred.data.astar.a.y
  df_tv <- reshape(pred.data.astar.a.y, direction = "long", varying = vector_time_points,
                   sep = "_", times = as.character(seq_along(time_points)),
                   idvar = 'id_unique')
  df_tv <- df_tv[order(df_tv$id_unique), ]
  df_pred.data.astar.a.y <- df_tv[, match(getvarnames(Y$call)$xvar, colnames(df_tv)), drop = FALSE]
  df_pred.data.astar.a.y <- model.matrix(~ ., data = df_pred.data.astar.a.y)[, -1, drop = FALSE]
  
  # ----- contrasts -----
  PredictY_DEIEM   <- mean(tcrossprod(YModel, df_pred.data.astar.a.y))
  PredictY_TEDE_2  <- mean(tcrossprod(YModel, df_pred.data.a.y))
  PredictY_IEMIED  <- mean(tcrossprod(YModel, df_pred.data.astar.a.astar.a.y))
  PredictY_IEDTE_1 <- mean(tcrossprod(YModel, df_pred.data.astar.y))
  
  DE  <- mean(PredictY_DEIEM  - PredictY_TEDE_2)  * peryr
  IEM <- mean(PredictY_IEDTE_1 - PredictY_IEMIED) * peryr
  IED <- mean(PredictY_IEMIED  - PredictY_DEIEM)  * peryr
  TE  <- mean(PredictY_IEDTE_1 - PredictY_TEDE_2) * peryr
  
  effects <- cbind(DE, IEM, IED, TE)
  return(effects)
  

}
```

changed section of med_longitudinal
```{r}
  # Predict Y
  # Data augmentation method for person-time database
  # PredictY_DEIEM: a*, D1_a, M1_aD1a, D2_aD1aM1aD1a, M2_aD1aM1aD2a
  # PredictY_TEDE_2: a, D1_a, M1_aD1a, D2_aD1a M1aD1a, M2_aD1aM1aD2a
  # PredictY_IEMIED: a*, D1_a, M1_a*D1a, D2_aD1a M1a*D1a, M2_a*D1aM1a*D2a
  # PredictY_IEDTE_1: a*, D1_a*, M1_a*D1a*, D2_a*D1a*M1a*D1a*, M2_a*D1a*M1a*D2a*
  
  pred.data.a.y <- pred.data.astar.y <- pred.data.astar.a.y <- pred.data.astar.a.astar.a.y <- data[,c('id_unique',getvarnames(Y$call)$xvar[-2],m,colnames(data)[grep('time.since.first.exam', colnames(data))])]
  pred.data.a.y[, treat] <- control.value
  pred.data.astar.y[, treat] <- pred.data.astar.a.y[, treat] <- pred.data.astar.a.astar.a.y[, treat] <- treat.value
  pred.data.a.y[, m] <- pred.data.astar.a.y[, m] <- PredictM_a
  pred.data.astar.y[, m] <- PredictM_astar
  pred.data.astar.a.astar.a.y[, m] <- PredictM_a_astar
  pred.data.astar.a.astar.a.y[, m[1]] <- PredictM_a[,1]
  
  
  ########################
  
  # Data augmentation method for the counterfactuals
  vector_time_points <- c()
  for (i in 1:length(time_points)){
    vector_time_points <- c(vector_time_points, m[i], time_points[i])
  }
  
  # pred.data.a.y
  df_tv <- reshape(pred.data.a.y, direction = "long", varying = vector_time_points,
                   sep = "_", times=as.character(seq(1,length(time_points))), idvar='id_unique')
  df_tv <- df_tv[order(df_tv$id_unique),]
  df_pred.data.a.y <- df_tv[,match(getvarnames(Y$call)$xvar,colnames(df_tv))]
  df_pred.data.a.y <- model.matrix(~.,data=df_pred.data.a.y)[,-1]
  
  # pred.data.astar.y
  df_tv <- reshape(pred.data.astar.y, direction = "long", varying = vector_time_points,
                   sep = "_", times=as.character(seq(1,length(time_points))), idvar='id_unique')
  df_tv <- df_tv[order(df_tv$id_unique),]
  df_pred.data.astar.y <- df_tv[,match(getvarnames(Y$call)$xvar,colnames(df_tv))]
  df_pred.data.astar.y <- model.matrix(~.,data=df_pred.data.astar.y)[,-1]
  
  # pred.data.astar.a.astar.a.y
  df_tv <- reshape(pred.data.astar.a.astar.a.y, direction = "long", varying = vector_time_points,
                   sep = "_", times=as.character(seq(1,length(time_points))), idvar='id_unique')
  df_tv <- df_tv[order(df_tv$id_unique),]
  df_pred.data.astar.a.astar.a.y <- df_tv[,match(getvarnames(Y$call)$xvar,colnames(df_tv))]
  df_pred.data.astar.a.astar.a.y <- model.matrix(~.,data=df_pred.data.astar.a.astar.a.y)[,-1]
  
  # pred.data.astar.a.y
  df_tv <- reshape(pred.data.astar.a.y, direction = "long", varying = vector_time_points,
                   sep = "_", times=as.character(seq(1,length(time_points))), idvar='id_unique')
  df_tv <- df_tv[order(df_tv$id_unique),]
  df_pred.data.astar.a.y <- df_tv[,match(getvarnames(Y$call)$xvar,colnames(df_tv))]
  df_pred.data.astar.a.y <- model.matrix(~.,data=df_pred.data.astar.a.y)[,-1]
  
  #######################
  
  PredictY_DEIEM <- mean(tcrossprod(YModel, df_pred.data.astar.a.y))
  PredictY_TEDE_2 <- mean(tcrossprod(YModel, df_pred.data.a.y))
  PredictY_IEMIED <- mean(tcrossprod(YModel, df_pred.data.astar.a.astar.a.y))
  PredictY_IEDTE_1 <- mean(tcrossprod(YModel, df_pred.data.astar.y))
  
  DE <- mean(PredictY_DEIEM - PredictY_TEDE_2)*100000
  IEM <- mean(PredictY_IEDTE_1 - PredictY_IEMIED)*100000
  IED <- mean(PredictY_IEMIED - PredictY_DEIEM)*100000
  TE <- mean(PredictY_IEDTE_1 - PredictY_TEDE_2)*100000
  effects <- cbind(DE, IEM, IED, TE)
  return(effects)
```

